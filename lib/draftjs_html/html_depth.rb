module DraftjsHtml
  # This class manages the depth and nesting of the myriad HTML tags generated by DraftjsHtml::ToHtml.
  # It is intended to be a private implementation detail.
  class HtmlDepth # :nodoc:
    BLOCK_TYPE_TO_HTML_WRAPPER = {
      'code-block' => 'pre',
      'ordered-list-item' => 'ol',
      'unordered-list-item' => 'ul',
    }.freeze

    def initialize(body)
      @current_depth = 0
      @body = body
      @previous_block = nil
    end

    LIST_ROOTS = %w[ol ul]

    def apply(block)
      if block.type == 'code-block'
        push_parent(block)
        store_previous(block)
        return
      end

      # Nesting lists - extra content same level
      if @current_depth > 0 && block.depth == @current_depth && block.type != @previous_block&.type
        set_li_as_root
        store_previous(block)
        return
      end

      # Nesting lists - deepening inside a proper list
      if block.depth == @current_depth + 1 && block.type == @previous_block&.type
        set_li_as_root
        push_parent(block)
        store_previous(block)
        return
      end

      # Nesting lists - deepening skipping level 0
      if block.depth > @current_depth && !list_block?(@previous_block)
        while @current_depth < block.depth
          push_parent(block)
          @body.parent = create_child('li')
          @current_depth += 1
        end
        push_parent(block)
        store_previous(block)
        return
      end

      # Nesting lists - deepening from inside skipping several levels
      if block.depth > @current_depth && list_block?(@previous_block)
        set_li_as_root
        while block.depth > @current_depth + 1
          push_parent(block)
          @body.parent = create_child('li')
          @current_depth += 1
        end
        push_parent(block)
        store_previous(block)
        return
      end

      # Nesting lists - rising
      if block.depth < @current_depth
        # pop_to_nearest_list_root, n times
        (@current_depth - block.depth).times do
          if @body.parent.name == 'li'
            pop_parent
            pop_parent
            pop_parent
          elsif LIST_ROOTS.include?(@body.parent.name)
            pop_parent
            pop_parent
          else
            pop_parent
          end
        end
      end

      # Sibling list items
      if block.depth == 0 && list_block?(block) && @previous_block&.type == block.type
        store_previous(block)
        return
      end

      # Any-old root list item
      if block.depth == 0 && list_block?(block) && @previous_block&.depth.to_i == 0
        push_parent(block)
        store_previous(block)
        return
      end

      # Leaving the list
      if block.depth == 0 && !list_block?(block) && (list_block?(@previous_block) || @previous_block&.depth.to_i > 0)
        pop_to_document_root
        store_previous(block)
        return
      end

      store_previous(block)
    end

    private

    def store_previous(block)
      @current_depth = block.depth
      @previous_block = block
    end

    def list_block?(block)
      block&.type&.end_with?('list-item')
    end

    def pop_to_document_root
      pop_parent until current_root_name == 'body'
    end

    def current_root_name
      @body.parent.name
    end

    def push_parent(block)
      tagname = BLOCK_TYPE_TO_HTML_WRAPPER[block.type]
      node = create_child(tagname)
      @body.parent = node
    end

    def pop_parent
      @body.parent = @body.parent.parent
    end

    def create_child(tagname)
      @body.parent.add_child(@body.doc.create_element(tagname))
    end

    def set_li_as_root
      @body.parent = @body.parent.last_element_child
    end
  end
end
